/* automatically generated by rust-bindgen 0.69.4 */
// extern "C" {
//     pub fn tflite_plugin_create_delegate(
//         options_keys: *const *const ::std::os::raw::c_char,
//         options_values: *const *const ::std::os::raw::c_char,
//         num_options: usize,
//         report_error: ::std::option::Option<
//             unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char),
//         >,
//     ) -> *mut TfLiteDelegate;
// }
// extern "C" {
//     pub fn tflite_plugin_destroy_delegate(delegate: *mut TfLiteDelegate);
// }

use crate::TfLiteDelegate;
use libloading::{Library, Symbol};
use std::{
    error::Error,
    ffi::OsStr,
    io,
    path::Path,
    ptr,
};

#[allow(dead_code)]
pub struct Delegate {
    pub delegate: ptr::NonNull<TfLiteDelegate>,
    free: unsafe extern "C" fn(*mut TfLiteDelegate),

    // this is needed to keep the library in memory so that the external library's destructor can be called
    external_lib: Option<Library>,
}

impl Delegate {
    fn _load_library<P>(path: P) -> Result<Library, Box<dyn std::error::Error>>
    where
        P: AsRef<OsStr>,
    {
        unsafe { Ok(Library::new(path)?) }
    }

    fn _load_external(lib: &Library) -> Result<*mut TfLiteDelegate, Box<dyn std::error::Error>> {
        unsafe {
            let func: Symbol<
                unsafe extern "C" fn(
                    options_keys: *const *const ::std::os::raw::c_char,
                    options_values: *const *const ::std::os::raw::c_char,
                    num_options: usize,
                    report_error: ::std::option::Option<
                        unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char),
                    >,
                ) -> *mut TfLiteDelegate,
            > = lib.get(b"tflite_plugin_create_delegate")?;
            // todo: add options
            Ok(func(ptr::null(), ptr::null(), 0, None))
        }
    }
    fn drop_external_fn(
        lib: &Library,
    ) -> Result<Symbol<unsafe extern "C" fn(delegate: *mut TfLiteDelegate)>, Box<dyn Error>> {
        unsafe {
            let func: Symbol<unsafe extern "C" fn(delegate: *mut TfLiteDelegate)> =
                lib.get(b"tflite_plugin_destroy_delegate")?;
            // todo: add options
            Ok(func)
        }
    }

    pub fn load_external<P>(path: P) -> Result<Delegate, Box<dyn Error>>
    where
        P: AsRef<Path>,
    {
        let lib = Self::_load_library(path.as_ref().as_os_str())?;
        let delegate = Self::_load_external(&lib)?;
        let delegate = ptr::NonNull::new(delegate).ok_or(Box::new(io::Error::new(
            io::ErrorKind::InvalidInput,
            "tflite_plugin_create_delegate returned NULL",
        )))?;
        // this is safe because the external_lib variable holds the lib.
        let drop_fn = *(Self::drop_external_fn(&lib)?);
        Ok(Delegate {
            delegate,
            free: drop_fn,
            external_lib: Some(lib),
        })
    }
}

impl Drop for Delegate {
    fn drop(&mut self) {
        unsafe { (self.free)(self.delegate.as_ptr()) };
    }
}
